extends ../../layout/layout

block variables
  - var title = 'Селекторы.'
  - var pageClass = 'article-page'

block content
  main
    article.article.article--with-navigation.container
      h1= title
      nav
        ol
          li #[a(href='#selector-by-tag') Селектор по тегу.]
          li #[a(href='#selector-by-class') Селектор по классу.]
          li #[a(href='#context-selectors') Контекстные селекторы.]
          li #[a(href='#child-selectors') Дочерние селекторы.]
          li #[a(href='#adjacent-selectors') Соседние селекторы.]
          li #[a(href='#subsequent-element-selector') Селектор последующих элементов.]
          li #[a(href='#selector-by-id') Селектор по id.]
          li #[a(href='#selector-by-attribute') Селектор по атрибуту.]
            ol
              li #[a(href='#selector-by-attribute-start-substring') Селектор по подстроке в начале значения атрибута.]
              li #[a(href='#selector-by-attribute-end-substring') Селектор по подстроке в конце значения атрибута.]
              li #[a(href='#selector-by-attribute-substring') Селектор по подстроке в значении атрибута.]
              li #[a(href='#selector-by-attribute-word')  Селектор по слову в значении атрибута.]
              li #[a(href='#selector-by-attribute-prefix') Селектор по префиксу в значении атрибута.]
          li #[a(href='#pseudo-classes') Псевдоклассы.]
            ol
              li #[a(href='#pseudo-class-root') Псевдокласс root.]
              li #[a(href='#pseudo-class-counter') Выбор элементов на основе счётчика.]
              li #[a(href='#pseudo-classes-interactive') Псевдоклассы для интерактивных элементов.]
              li #[a(href='#pseudo-classes-form') Псевдоклассы для полей формы.]
              li #[a(href='#pseudo-classes-helper') Вспомогательные псевдоклассы.]
          li #[a(href='#pseudo-elements') Псевдоэлементы.]
            ol
              li #[a(href='#pseudo-elements-text') Псевдоэлементы для оформления текста.]
              li #[a(href='#pseudo-elements-before-after') Псевдоэлементы before и after.]
          li #[a(href='#combining-selectors') Комбинирование селекторов.]
            ol
              li #[a(href='#selector-by-tag-and-class') Селектор по тегу и классу.]
              li #[a(href='#using-subsequent-with-checked') Использование ~ с checked.]
              li #[a(href='#association-of-pseudo-classes') Объединение псевдоклассов.]
              li #[a(href='#using-context-with-nth-child') Псевдокласс nth-child и контекстные селекторы.]
              li #[a(href='#styling-depending-on-quantity')  Динамическая стилизация элементов в зависимости от их количества.]

      h2#selector-by-tag Селектор по тегу.
      p Селектор по тегу содержит название тега без символов #[b &lt;] и #[b &gt;], и выбирает все теги с таким названием.
      p Пример:
      pre
        code.
          li {
            /* Стили для элементов списка. */
          }
      h2#selector-by-class Селектор по классу.
      P Селектор по классу содержит название класса выбирает все элементы с таким классом.
      p Перед названием класса пишется точка (#[b .]).
      p Пример:
      pre
        code.
          .heading {
            /* Стили для класса heading. */
          }
      h2#context-selectors Контекстные селекторы.
      p Можно комбинировать любые типы селекторов через пробел. Такие селекторы называются #[i вложенными] или #[i контекстными] и используются, чтобы применить стили к элементу, только если он вложен в нужный элемент. Читаются справа налево.
      p Пример:
      pre
        code.
          nav a { ... } /* Выберет теги a внутри тегов nav. */
          .menu ul { ... } /* Выберет теги ul внутри тегов с классом menu. */
          .post .title { ... } /* Выберет теги с классом title внутри тегов с классом post. */
      p Комбинировать можно любое количество селекторов, но лучше использовать двойную или максимум тройную вложенность.
      pre
        code.
          /* Выберет все ссылки внутри элементов с классом menu, которые лежат внутри элементов с классом footer. */
          .footer .menu a { ... }
      p Вложенные селекторы спасают от необходимости придумывать имена классов и загромождать ими разметку. Можно задавать элементам различные стили в зависимости от их контекста. Например, если ссылка расположена внутри меню, сделать её крупнее, а если внутри основного текста, то задать ей нужный цвет.
      h2#child-selectors Дочерние селекторы.
      p #[i Потомками] называются любые элементы, расположенные внутри родительского элемента. А #[i дочерними] элементами называются ближайшие потомки.
      p Взгляните на пример:
      pre
        code.
          &lt;ul&gt;
            &lt;li&gt;&lt;span&gt; ... &lt;/span&gt;&lt;/li&gt;
            &lt;li&gt;&lt;span&gt; ... &lt;/span&gt;&lt;/li&gt;
          &lt;/ul&gt;
      p По отношению к списку #[b &lt;ul&gt;&lt;/ul&gt;] элементы #[b &lt;li&gt;&lt;/li&gt;] являются дочерними элементами и потомками, а #[b &lt;span&gt;&lt;/span&gt;] — потомки, но не дочерние элементы.
      p Контекстные селекторы влияют на всех потомков, что не всегда удобно. Иногда необходимо задать стили только для дочерних элементов. Для этого существует дочерний селектор, в котором используется символ #[b &gt;].
      p Примеры:
      pre
        code.
          ul &gt; li { ... }
          ul &gt; li &gt; span { ... }
      h2#adjacent-selectors Соседние селекторы.
      p Контекстные селекторы используются для вложенных друг в друга элементов, а соседние — для расположенных рядом.
      p Например, теги #[b &lt;li&gt;&lt;/li&gt;] являются соседними по отношению друг к другу и вложенными в тег #[b &lt;ul&gt;&lt;/ul&gt;].
      p Соседние селекторы записываются с помощью знака #[b +], например, #[b селектор-1 + селектор-2]. Стили применятся к элементу, подходящему под #[b селектор-2], только если #[em сразу] перед ним расположен элемент, подходящий под #[b селектор-1].
      p Пример. Есть два элемента списка:
      pre
        code.
          &lt;ul&gt;
            &lt;li class="hit"&gt; ... &lt;/li&gt;
            &lt;li class="miss"&gt; ... &lt;/li&gt;
          &lt;/ul&gt;
      p Селектор #[b .hit] + #[b .miss] применит стили к элементу с классом #[b miss], так как перед ним есть элемент с классом #[b hit].
      p Селектор #[b .hit + li], а также селектор #[b li + .miss], или даже #[b li + li] тоже применит стили к элементу с классом #[b miss], то есть ко второму элементу списка.
      p А вот селектор #[b .miss + .hit] не сработает, так как в разметке перед элементом с классом #[b hit] нет элемента с классом #[b miss].
      h2#subsequent-element-selector Селектор последующих элементов.
      p Селекторы последующих элементов записываются с помощью знака #[b ~], например, #[b селектор-1 ~ селектор-2]. Стили применятся к элементу, подходящему под #[b селектор-2], только если перед ним расположен элемент, подходящий под #[b селектор-1]. Оба элемента должны находиться на одном уровне вложенности.
      p Отличие от соседнего селектора #[b +] состоит в том, что между элементами #[b селектор-1] и #[b селектор-2] могут находиться другие элементы.
      p Пример:
      pre
        code.
          &lt;ul class="cards"&gt;
            &lt;li class="king diamond"&gt;&lt;/li&gt;
            &lt;li class="queen heart"&gt;&lt;/li&gt;
            &lt;li class="jack spade"&gt;&lt;/li&gt;
            &lt;li class="ace heart"&gt;&lt;/li&gt;
            &lt;li class="king club"&gt;&lt;/li&gt;
          &lt;/ul&gt;
      p Сравним два селектора:
      pre
        code.
          .queen.heart + li { ... }
          .king.diamond ~ li { ... }
      p В первом случае выберется одна карта, расположенная сразу за червовой дамой, то есть пиковый валет.
      p Во втором случае выделятся все карты, которые стоят за бубновым королём, то есть червовая дама, пиковый валет, червовый туз и трефовый король.
      h2#selector-by-id Селектор по id.
      P Селектор по идентификатору (HTML-атрибуту #[b id]) содержит название идентификатора и выбирает элемент с таким идентификатором.
      p Перед названием идентификатора пишется символ #[b #].
      p Пример:
      pre
        code.
          &lt;!-- HTML --&gt;
          &lt;p id="greeting"&gt;Приветствие!&lt;/p&gt;

          /* CSS */
          #greeting {
            ...
          }
      p Использование селекторов по #[b id] при оформлении считается плохой практикой. Существуют редкие исключения из этого правила, например, при оживлении слайдера на чистом CSS.
      h2#selector-by-attribute Селектор по атрибуту.
      p Существуют селекторы, которые позволяют выбирать элементы по атрибутам.
      p Чаще всего такие селекторы используются при работе с формами, так как поля форм имеют атрибут #[b type] с разными значениями.
      p Селекторы атрибутов записываются с использованием квадратных скобок: #[b &#91;атрибут&#93;].
      p Примеры:
      pre
        code.
          input[checked] { ... }
          input[type="text"] { ... }
      p Первый селектор выберет поля формы, у которых есть атрибут #[b checked], второй селектор выберет поля формы, у которых атрибут #[b type] имеет значение #[b text].
      p Селектор по атрибуту не обязательно использовать в комбинации с селектором по тегу.
      h3#selector-by-attribute-start-substring Селектор по подстроке в начале значения атрибута.
      p Селектор #[b &#91;имя_атрибута^="подстрока"&#93;] выбирает все элементы, у которых значение атрибута начинается с указанной подстроки.
      p Например, есть 3 блока с классами #[b column-1], #[b column-2] и #[b column-3]. Они имеют почти одинаковое оформление, разной является только ширина.
      pre
        code.
          &lt;div class="column-1"&gt; ... &lt;/div&gt;
          &lt;div class="column-2"&gt; ... &lt;/div&gt;
          &lt;div class="column-3"&gt; ... &lt;/div&gt;
      p Чтобы не дублировать CSS-код, можно вынести общие свойства в правило с селектором #[b &#91;class^="column-"&#93;], а в остальных правилах задать только ширину.
      pre
        code.
          [class^="column-"] {
            /* Общие свойства: отступы, рамки, фон и т.п. */
          }

          .column-1 { width: 100px; }
          .column-2 { width: 200px; }
          .column-3 { width: 300px; }
      h3#selector-by-attribute-end-substring Селектор по подстроке в конце значения атрибута.
      p Селектор #[b &#91;имя_атрибута$="подстрока"&#93;] выбирает все элементы, у которых значение атрибута оканчивается указанной подстрокой.
      p Например, на сайте есть раздел с файлами для скачивания в разных форматах и нужно для каждого типа файлов добавить свою иконку.
      pre
        code.
          &lt;a href="book.pdf" download&gt;Скачать&lt;/a&gt;
          &lt;a href="book.doc" download&gt;Скачать&lt;/a&gt;
          &lt;a href="book.fb2" download&gt;Скачать&lt;/a&gt;
      p В этом случае в CSS можно назначать иконки по расширениям файлов:
      pre
        code.
          a[href$=".pdf"] { /* Иконка для PDF. */ }
          a[href$=".doc"] { /* Иконка для DOC. */ }
          a[href$=".fb2"] { /* Иконка для FB2. */ }
      h3#selector-by-attribute-substring Селектор по подстроке в значении атрибута.
      p Селектор #[b &#91;имя_атрибута*="подстрока"&#93;] выбирает все элементы, значение атрибута которых содержит указанную подстроку на любой позиции.
      p Например, среди трёх элементов:
      pre
        code.
          &lt;p class="person-name"&gt; ... &lt;/p&gt;
          &lt;div class="some-person-info"&gt; ... &lt;/div&gt;
          &lt;span class="date-person"&gt; ... &lt;/span&gt;
      p cелектор #[b &#91;class*="person"&#93;] выберет все.
      h3#selector-by-attribute-word Селектор по слову в значении атрибута.
      p Селектор #[b &#91;имя_атрибута~="слово"&#93;] выбирает все элементы, у которых значение атрибута содержит указанное слово.
      p Входить должно именно слово, а не просто подстрока. То есть слово должно содержать с обеих сторон разделители: пробелы или начало/конец строки.
      h3#selector-by-attribute-prefix Селектор по префиксу в значении атрибута.
      p Селектор #[b &#91;имя_атрибута|="префикс"&#93;] выбирает все элементы, у которых значение атрибута содержит указанный префикс, то есть либо полностью совпадает с префиксом, либо начинается c префикса, за которым сразу следует дефис (#[b -]).
      pre
        code.
          [имя_атрибута|="префикс"] { ... }
          /*
          Этот селектор заменяет собой два других:
          [имя_атрибута="префикс"]
          [имя_атрибута^="префикс-"]
          */
      h2#pseudo-classes Псевдоклассы.
      p #[dfn Псевдоклассы] — это селекторы, которые могут использоваться самостоятельно или как дополнения к другим селекторам, делая их специфичнее.
      p Имена псевдоклассов начинаются с двоеточия (#[b :]), вот так #[b :псевдокласс].
      p Примеры:
      pre
        code.
          a:visited { ... }
          li:last-child { ... }
          .alert:hover { ... }
      h3#pseudo-class-root Псевдокласс root.
      ul
        li #[a(href='../css-pseudo-classes/root.html') root] — корневой элемент дерева документа.
      h3#pseudo-class-counter Выбор элементов на основе счётчика.
      ul
        li #[a(href='../css-pseudo-classes/first-child.html') first-child] — первый  элемент родителя.
        li #[a(href='../css-pseudo-classes/last-child.html') last-child] — последний элемент родителя.
      ul
        li #[a(href='../css-pseudo-classes/first-of-type.html') first-of-type] — первые элементы разных типов среди дочерних.
        li #[a(href='../css-pseudo-classes/last-of-type.html') last-of-type] — последние элементы разных типов среди дочерних.
      ul
        li #[a(href='../css-pseudo-classes/nth-child.html') nth-child] — элемент по порядкому номеру с начала.
        li #[a(href='../css-pseudo-classes/nth-last-child.html') nth-last-child] — элемент по порядкому номеру с конца.
      ul
        li #[a(href='../css-pseudo-classes/nth-of-type.html') nth-of-type] — элементы разных типов по порядкому номеру с начала.
        li #[a(href='../css-pseudo-classes/nth-last-of-type.html') nth-last-of-type] — элементы разных типов по порядкому номеру с конца.
      ul
        li #[a(href='../css-pseudo-classes/only-child.html') only-child] — единственные элементы в родителе.
        li #[a(href='../css-pseudo-classes/only-of-type.html') only-of-type] — единственные элементы своего типа в родителе.
      ul
        li #[a(href='../css-pseudo-classes/empty.html') empty] — пустые элементы.
      h3#pseudo-classes-interactive Псевдоклассы для интерактивных элементов.
      ul
        li #[a(href='../css-pseudo-classes/link.html') link] — непосещённые ссылки.
        li #[a(href='../css-pseudo-classes/visited.html') visited] — посещённые ссылки.
        li #[a(href='../css-pseudo-classes/focus.html') focus] — элементы в фокусе.
        li #[a(href='../css-pseudo-classes/hover.html') hover] — элементы при наведении.
        li #[a(href='../css-pseudo-classes/active.html') active] — элементы при нажатии.
      ul
        li #[a(href='../css-pseudo-classes/focus-visible.html') focus-visible] — элементы в фокусе с клавиатуры.
        li #[a(href='../css-pseudo-classes/focus-within.html') focus-within] — элементы в фокусе, либо имеющие потомков в фокусе.
      p Пример стилизации ссылок:
      pre
        code.
          a:link { ... }
          a:visited { ... }
          a:focus { ... }
          a:hover { ... }
          a:active { ... }
      p Обратите внимание на порядок правил. Если их расположить по-другому, то некоторые могут не сработать.
      h3#pseudo-classes-form Псевдоклассы для полей формы.
      ul
        li #[a(href='../css-pseudo-classes/enabled.html') enabled] — доступные поля (без атрибута #[b disabled]).
        li #[a(href='../css-pseudo-classes/disabled.html') disabled] — заблокированные поля (с атрибутом #[b disabled]).
      ul
        li #[a(href='../css-pseudo-classes/read-only.html') read-only] — поля, доступные только для чтения (с атрибутом #[b read-only]).
        li #[a(href='../css-pseudo-classes/read-write.html') read-write] — поля без атрибута #[b read-only].
      ul
        li #[a(href='../css-pseudo-classes/required.html') required] — обязательные для заполнения поля (с атрибутом #[b required]).
        li #[a(href='../css-pseudo-classes/optional.html') optional] — поля без атрибута #[b required].
      ul
        li #[a(href='../css-pseudo-classes/checked.html') checked] — отмеченные поля.
      ul
        li #[a(href='../css-pseudo-classes/valid.html') valid] — валидно заполненные поля.
        li #[a(href='../css-pseudo-classes/invalid.html') invalid] — поля, заполненные невалидно.
      ul
        li #[a(href='../css-pseudo-classes/in-range.html') in-range] — числовые поля со значениями в заданном диапазоне.
        li #[a(href='../css-pseudo-classes/out-of-range.html') out-of-range] — числовые поля со значениями вне заданного диапазона.
      h3#pseudo-classes-helper Вспомогательные псевдоклассы.
      ul
        li #[a(href='../css-pseudo-classes/not.html') not] — отрицание наличия другого селектора.
      h2#pseudo-elements Псевдоэлементы
      p Псевдоэлементы добавляются к селектору с помощью символа #[b ::], вот так #[b селектор::псевдоэлемент].
      h3#pseudo-elements-text Псевдоэлементы для оформления текста.
      ul
        li #[a(href='../css-pseudo-elements/first-letter.html') first-letter] — первый символ текста.
        li #[a(href='../css-pseudo-elements/first-line.html') first-line] — первая строка текста.
      h3#pseudo-elements-before-after Псевдоэлементы before и after.
      ul
        li #[a(href='../css-pseudo-elements/before.html') before] — псевдо-span в начале элемента.
        li #[a(href='../css-pseudo-elements/after.html') after] — псевдо-span в конце элемента.
      p Псевдоэлементам #[b before] и #[b after] можно задавать любые CSS-свойства: менять их тип бокса, задавать позиционирование, отступы, фон и так далее.
      p Этими возможностями особенно часто пользуются при создании различных декоративных эффектов. Это очень удобно. Во-первых, не нужно добавлять лишний тег под каждую очередную мелкую иконку. Во-вторых, можно управлять этими иконками/декоративными элементами только с помощью CSS, что открывает огромный простор для создания интересных динамических эффектов.
      h2#combining-selectors Комбинирование селекторов.
      p В CSS можно очень гибко комбинировать селекторы в неограниченном количестве.
      p Например, селектор #[b .player-1 .hit + .miss] сработает для тега с классом #[b miss], если сразу перед ним расположен тег с классом #[b hit] и оба тега расположены внутри тега с классом #[b player-1].
      h3#selector-by-tag-and-class Селектор по тегу и классу.
      p Синтаксис CSS позволяет выбирать элементы одновременно по тегу и классу или же элемент с несколькими классами сразу. Для этого селектор составляется одной строкой из всех желаемых «частей» без пробелов.
      p В селекторе по тегу и классу первым пишется название тега, а потом класс:
      pre
        code.
          div.blue { ... }  /* Выберет теги div с классом blue. */
          ul.target { ... } /* Выберет теги ul с классом target. */
      p Если у элемента задано несколько классов, в HTML и в CSS-селекторе они могут быть записаны в любом порядке — это не будет влиять на выборку элементов.
      pre
        code.
          .text.green { ... } /* Выберет теги с классами text и green. */
      p Количество классов в селекторе может быть любым:
      pre
        code.
          /* Выбор тегов span с 4 классами: underlined, red, big и text. */
          span.underlined.red.big.text { ... }
      h3#using-subsequent-with-checked Использование ~ с checked.
      p Благодаря псевдоклассу #[b checked], с помощью чистого CSS можно создавать очень много интересных эффектов, так как мы можем не просто выбирать отмеченные поля форм, но и влиять с помощью этих полей на другие элементы.
      p Для этого нужно комбинировать #[b checked] и #[b ~], который позволяет выбрать все элементы, идущие за отмеченным чекбоксом.
      p Пример:
      pre
        code.
          input:checked ~ .item {
            color: red;
          }
      p Такое CSS-правило задаст красный цвет всем элементам с классом #[b item], расположенным после отмеченного поля.
      p Получается, что мы можем с помощью чекбоксов или радиокнопок управлять внешним видом других элементов. С помощью этого приёма, например, делают переключающиеся вкладки, которые работают без JavaScript.
      h3#association-of-pseudo-classes Объединение псевдоклассов.
      p Псевдоклассы, как и любые другие селекторы, можно комбинировать между собой, соединять с селекторами другого типа и так далее.
      p Пример:
      pre
        code.
          input[type="checkbox"]:required:checked { ... }
      p Селектор выберет все отмеченные чекбоксы, которые являются обязательными.
      h3#using-context-with-nth-child Псевдокласс nth-child и контекстные селекторы.
      p Селекторы с псевдоклассами хорошо сочетаются с контекстными селекторами.
      p Например, следующий селектор выберет третий тег #[b &lt;li&gt;&lt;/li&gt;] внутри блока с классом #[b shooter-2].
      pre
        code.
          .shooter-2 li:nth-child(3) { ... }
      p Селектор не обязательно должен заканчиваться псевдоклассом. Например, следующий селектор выберет элемент с классом #[b text] в четвёртом элементе списка #[b &lt;li&gt;&lt;/li&gt;].
      pre
        code.
          li:nth-child(4) .text { ... }
      h3#styling-depending-on-quantity Динамическая стилизация элементов в зависимости от их количества.
      p Задача:
      p Есть список из меняющегося числа элементов. Если элементов меньше 4, то они должны быть красными, если меньше 6, то жёлтыми, в противном случае зелёными.
      pre
        code.
          li {
            color: green;
          }
          li:nth-last-child(-n+5):first-child,
          li:nth-last-child(-n+5):first-child ~ li {
            color: yellow;
          }
          li:nth-last-child(-n+3):first-child,
          li:nth-last-child(-n+3):first-child ~ li {
            color: red;
          }
      p Сначала зададим цвет по умолчанию — зелёный.
      p Второе правило выбирает последние 5 элементов и если среди них есть первый элемент списка, значит элементов в списке 5 или меньше, селекторы сработают и закрасит элементы в жёлтый.
      p Третье правило выбирает последние 3 элемента и если среди них есть первый элемент списка, значит элементов в списке 3 или меньше, селекторы сработают и переопределит жёлтый цвет в красный. Важно, чтобы это правило располагалось ниже второго.
