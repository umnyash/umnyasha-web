extends ../../layout/layout

block variables
  - var title = 'Советы по оптимизации.'
  - var pageClass = 'article-page'

block content
  main
    article.article.container
      h1= title
      h2 Предварительная визуализация похожих примитивов или повторяющихся объектов на закадровом холсте.
      p Если в каждом кадре анимации повторяются одни и те же операции, их можно выгрузить на закадровый холст. Затем отрисовывать это закадровое изображение на основной холст, без необходимости повторять шаги для его создания.
      p Пример:
      pre
        code.
          myCanvas.offscreenCanvas = document.createElement('canvas');
          myCanvas.offscreenCanvas.width = myCanvas.width;
          myCanvas.offscreenCanvas.height = myCanvas.height;

          myCanvas.getContext('2d').drawImage(myCanvas.offScreenCanvas, 0, 0);
      h2 Использование целочисленных координат, вместо координат с плавающей запятой.
      p Отрисовка объектов с дробными значениями координат заставляет браузер выполнять дополнительные вычисления для создания эффекта сглаживания. Чтобы избежать этого, можно, например, округлить все координаты с помощью #[b Math.floor].
      h2 Не масштабируйте изображения в drawImage.
      p Кэшируйте изображения различных размеров на закадровом холсте при загрузке, а не постоянно масштабируйте их в #[b drawImage].
      h2 Использование нескольких слоёв холста для сложных сцен.
      p В вашем приложении вы можете обнаружить, что некоторые объекты необходимо часто перемещать или изменять, в то время как другие остаются относительно статичными. Возможная оптимизация в этой ситуации — наслоить ваши элементы, используя несколько элементов #[b &lt;canvas&gt;&lt;/canvas&gt;].
      p Например, предположим, что у вас есть игра с пользовательским интерфейсом вверху, игровым процессом посередине и статическим фоном внизу. В этом случае вы можете разделить игру на три слоя Canvas. Пользовательский интерфейс будет меняться только при вводе данных пользователем, слой игрового процесса будет меняться с каждым новым кадром, а фон в целом останется неизменным.
      h2 Используйте простой CSS для больших фоновых изображений.
      p Если у вас есть статическое фоновое изображение, вы можете нарисовать его на простом элементе #[b &lt;div&gt;&lt;/div&gt;], используя CSS-свойство #[b background], и поместить его под холст. Это избавит от необходимости отрисовывать фон на холсте при каждом кадре.
      h2 Масштабирование холста с помощью CSS-трансформаций.
      P Преобразования CSS выполняются быстрее, поскольку они используют графический процессор. Лучше всего не масштабировать холст или иметь холст меньшего размера и увеличивать его, нежели иметь большой холст и уменьшать его.
      p Пример:
      pre
        code.
          const scaleX = window.innerWidth / canvas.width;
          const scaleY = window.innerHeight / canvas.height;

          const scaleToFit = Math.min(scaleX, scaleY);
          const scaleToCover = Math.max(scaleX, scaleY);

          stage.style.transformOrigin = '0 0'; //scale from top left
          stage.style.transform = `scale(${scaleToFit})`;
      h2 Отключение прозрачности.
      p Если ваше приложение использует холст и не нуждается в прозрачном фоне, установите для параметра альфа значение #[b false] при создании контекста рисования с помощью #[b HTMLCanvasElement.getContext]. Эта информация может использоваться браузером внутри для оптимизации рендеринга.
      pre
        code.
          const ctx = canvas.getContext('2d', { alpha: false });
      h2 Масштабирование для дисплеев с высоким разрешением.
      p Вы можете обнаружить, что элементы холста выглядят размытыми на дисплеях с более высоким разрешением. Хотя может существовать множество решений, простым первым шагом является одновременное масштабирование размера холста вверх и вниз, используя его атрибуты, стиль и масштаб контекста.
      pre
        code.
          // Get the DPR and size of the canvas
          const dpr = window.devicePixelRatio;
          const rect = canvas.getBoundingClientRect();

          // Set the "actual" size of the canvas
          canvas.width = rect.width * dpr;
          canvas.height = rect.height * dpr;

          // Scale the context to ensure correct drawing operations
          ctx.scale(dpr, dpr);

          // Set the "drawn" size of the canvas
          canvas.style.width = `${rect.width}px`;
          canvas.style.height = `${rect.height}px`;
      h2 Ещё советы:
      ul
        li Пакетный вызов Canvas. Например, нарисуйте полилинию вместо нескольких отдельных линий.
        li Избегайте ненужных изменений состояния холста.
        li Отрисовывайте только различия экрана, а не все новое состояние.
        li По возможности избегайте свойства #[a(href='shadow-blur.html') shadowBlur].
        li По возможности избегайте рендеринга текста.
        li Попробуйте разные способы очистки холста (#[b clearRect], #[b fillRect] и изменение размера холста).
        li Для анимации используйте #[b window.requestAnimationFrame] вместо #[b setInterval].
        li Будьте осторожны с тяжелыми физическими библиотеками.
