extends ../../layout/layout

block variables
  - var title = 'Промисы.'
  - var pageClass = 'article-page'

block content
  main
    article.article.container
      h1= title
      p Объект #[b Promise] используется для отложенных и асинхронных вычислений.
      p Его интерфейс представляет собой обёртку для значения, неизвестного на момент создания промиса. Он позволяет обрабатывать результаты асинхронных операций так, как если бы они были синхронными: вместо конечного результата асинхронного метода возвращается своего рода #[i обещание] получить результат в некоторый момент в будущем.
      pre
        code.
          new Promise(executor);
          new Promise(function(resolve, reject) { ... });
      p Функция-исполнитель принимает два аргумента: колбэки #[b resolve] и #[b reject], и запускается сразу ещё до того, как констуктор вернёт созданный объект.
      p #[b Promise] может находиться в трёх состояниях:
      ul
        li #[b "pending"] («ожидание») — начальное состояние.
        li #[b "fulfilled"] («выполнено») — после вызова #[b resolve].
        li #[b "rejected"] («отклонено») — после вызова #[b reject] или если произошла ошибка в синхронном коде.
      p Состояние промиса хранится в свойстве #[b state] и может быть изменено только один раз.
      p Cвойство #[b result] хранит результат выполнения промиса — вначале #[b undefined], потом меняется на аргумент, переданный в #[b resolve] или #[b reject].
      p Колбэки #[b resolve] и #[b reject] могут быть вызваны с аргументами любого типа, но для #[b reject] рекомендуется использовать объект #[b Error] или унаследованный от него.
      p Свойства #[b state] и #[b result] — это внутренние свойства объекта и мы не имеем к ним прямого доступа. Для обработки результата следует использовать методы промиса.
      h2 Методы промиса.
      h3 then.
      p Метод #[b then] используется, чтобы выполнить код после изменения состояния промиса.
      pre
        code.
          promise.then(onFulfilled, onRejected);
      p Метод может принимать два аргумента:
      ol
        li #[b onFulfilled] — функция-колбэк, которая будет вызвана после перехода промиса в состояние #[b "fulfilled"].
        li #[b onRejected] — функция-колбэк, которая будет вызвана после перехода промиса в состояние #[b "rejected"].
      p Обе этих функций имеют один параметр, в который передаётся результат выполнения промиса.
      pre
        code.
          promise.then(
            function(result) { ... }
            function(result) { ... }
          );
      p Если метод будет обрабатывать только успешное выполнение промиса, то второй аргумент не нужен. Если метод будет обрабатывать только отклонение, то первым аргументои можно передать #[b null].
      p Обработчики метода #[b then] могут возвращать промис или #[i thenable] (любой объект содержащий метод #[b then]), который будет обработан как промис.
      p Если обработчик возвращает не #[i thenable], то это значение будет обернуто в промис.
      p Если обработчики ничего не возвращают явно, то по умолчанию возвращают #[b undefined], обернутый в промис.
      p По цепочке передаётся не сам промис, а его результат.
      h3 catch.
      p Под капотом #[b catch] содержит вызов #[b then], где первым аргументом передан #[b undefined].
      h3 finally.
      p Метод #[b finally] принимает один аргумент — колбэк, который будет выполнен после завершения промиса вне зависимости от его состояния.
      pre
        code.
          promise.finally(onFinally);
      ul
        li Обработчик #[b finally] не получает результат предыдущего обработчика (у него нет аргументов). Вместо этого этот результат передается следующему подходящему обработчику.
        li Обработчик #[b finally] не должен ничего возвращать. Если возвращает что-то, то это игнорируется.
      p Обработка промисов всегда асинхронная, т.к. все действия промисов проходят через внутреннюю очередь «promise jobs», так называемую «очередь микрозадач (microtask queue)» (термин v8).
      p Таким образом, обработчики в #[b then]/#[b catch]/#[b finally] вызываются после выполнения текущего кода.
      p Если промис в состоянии ожидания, обработчики в #[b then]/#[b catch]/#[b finally] будут ждать его. Если обработчик добавляется к уже выполенному промису, то он запускается немедленно.
      h2 Методы глобального объекта Promise.
      h3 resolve и reject.
      pre
        code.
          Promise.resolve(value);
          Promise.reject(reason);
      p Метод #[b resolve] возвращает промис выполненный с переданным значением.
      p Метод #[b reject] возвращает промис, который был отклонён по указанной причине.
      p На практике эти методы применяются в первую очередь для целей разработки: проверки кода, написания вспомогательных функций на промисах и т. д.
      h3 Методы для обработки нескольких промисов.
      p Следующие методы в качестве аргумента принимают промисы в виде перечисляемого объекта, например, массива.
      pre
        code.
          Promise.метод(iterable);
      p Если какой-либо элемент перечисляемого объекта не является промисом, то он будет преобразован с помощью метода #[b Promise.resolve].
      h3 all.
      p Метод #[b all] возвращает промис, который выполнится когда будут выполнены все переданные промисы или отклонится, сразу как будет отклонен любой из них.
      p В случае выполнения результатом станет массив результатов переданных промисов, сохраняющий порядок оригинального перечисляемого объекта.
      p В случае отклонения результатом станет результат отклонённого промиса.
      p Если в качестве аргумента будет передан пустой массив, то возвращаемый промис будет выполнен немедленно с результатом в виде пустого массива.
      h3 allSettled.
      p Метод #[b allSettled] возвращает промис, который выполнится когда все переданные промисы будут завершены.
      p Результатом станет массив объектов, каждый их которых содержит информацию об одном из завершенных промисов: статус в свойстве #[b status] и его результат в свойстве #[b value] или #[b reason] в зависимости от статуса.
      p Если в качестве аргумента будет передан пустой массив, то возвращаемый промис будет выполнен немедленно с результатом в виде пустого массива.
      h3 any.
      p Метод #[b any] возвращает промис, который выполнится когда будет выполнен любой из переданных промисов или отклонится, если все переданные промисы будут отклонены.
      p В случае выполнения результатом станет результат промиса, выполнившегося первым.
      p В случае отклонения результатом станет ошибка #[b AggregateError: All promises were rejected], которая в своём свойстве #[b errors] хранит все результаты отклоненных промисов.
      p Если в качестве аргумента будет передан пустой массив, то возвращаемый промис будет немедленно отклонён.
      h3 race.
      p Метод #[b race] возвращает промис, который выполнится или отклонится в зависимости от статуса промиса, завершившегося первым.
      p Результатом станет результат промиса, завершившегося первым.
      p Если в качестве аргумента будет передан пустой массив, то возвращаемый промис останется в состоянии #[b "pending"].
      h2 unhandledrejection.
      p Если происходит ошибка, и отсутствует её обработчик, то генерируется событие #[b unhandledrejection], и соответствующий объект #[b event] содержит информацию об ошибке.
      pre
        code.
          window.addEventListener('unhandledrejection', function(event) {
            // объект события имеет два специальных свойства:
            alert(event.promise); // [object Promise] - промис, который сгенерировал ошибку
            alert(event.reason); // Error: Ошибка! - объект ошибки, которая не была обработана
          });
      p Это даёт возможность отслеживать необработанные ошибки и информировать о них пользователя (и, возможно, наш сервер), благодаря чему наше приложение никогда не будет «просто умирать».
