<!DOCTYPE html><html class="page" lang="ru"><head><meta charset="utf-8"><title>Промисы</title><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="stylesheet" href="../../css/style.min.css"></head><body class="page__body"><div class="page__inner"><header class="page-header"><div class="container"><a class="logo" href="../../index.html">Umnyasha Web</a></div></header><main><article class="article container"><h1>Промисы</h1><p>Объект <b>Promise</b> используется для отложенных и асинхронных вычислений.</p><p>Его интерфейс представляет собой обёртку для значения, неизвестного на момент создания промиса. Он позволяет обрабатывать результаты асинхронных операций так, как если бы они были синхронными: вместо конечного результата асинхронного метода возвращается своего рода <i>обещание</i> получить результат в некоторый момент в будущем.</p><pre><code>new Promise(executor);
new Promise(function(resolve, reject) { ... });</code></pre><p>Функция-исполнитель принимает два аргумента: колбэки <b>resolve</b> и <b>reject</b>, и запускается сразу ещё до того, как констуктор вернёт созданный объект.</p><p><b>Promise</b> может находиться в трёх состояниях:</p><ul><li><b>"pending"</b> («ожидание») — начальное состояние.</li><li><b>"fulfilled"</b> («выполнено») — после вызова <b>resolve</b>.</li><li><b>"rejected"</b> («отклонено») — после вызова <b>reject</b> или если произошла ошибка в синхронном коде.</li></ul><p>Состояние промиса хранится в свойстве <b>state</b> и может быть изменено только один раз.</p><p>Cвойство <b>result</b> хранит результат выполнения промиса — вначале <b>undefined</b>, потом меняется на аргумент, переданный в <b>resolve</b> или <b>reject</b>.</p><p>Колбэки <b>resolve</b> и <b>reject</b> могут быть вызваны с аргументами любого типа, но для <b>reject</b> рекомендуется использовать объект <b>Error</b> или унаследованный от него.</p><p>Свойства <b>state</b> и <b>result</b> — это внутренние свойства объекта и мы не имеем к ним прямого доступа. Для обработки результата следует использовать методы промиса.</p><h2>Методы промиса</h2><h3>then</h3><p>Метод <b>then</b> используется, чтобы выполнить код после изменения состояния промиса.</p><pre><code>promise.then(onFulfilled, onRejected);</code></pre><p>Метод может принимать два аргумента:</p><ol><li><b>onFulfilled</b> — функция-колбэк, которая будет вызвана после перехода промиса в состояние <b>"fulfilled"</b>.</li><li><b>onRejected</b> — функция-колбэк, которая будет вызвана после перехода промиса в состояние <b>"rejected"</b>.</li></ol><p>Обе этих функций имеют один параметр, в который передаётся результат выполнения промиса.</p><pre><code>promise.then(
  function(result) { ... }
  function(result) { ... }
);</code></pre><p>Если метод будет обрабатывать только успешное выполнение промиса, то второй аргумент не нужен. Если метод будет обрабатывать только отклонение, то первым аргументои можно передать <b>null</b>.</p><p>Обработчики метода <b>then</b> могут возвращать промис или <i>thenable</i> (любой объект содержащий метод <b>then</b>), который будет обработан как промис.</p><p>Если обработчик возвращает не <i>thenable</i>, то это значение будет обернуто в промис.</p><p>Если обработчики ничего не возвращают явно, то по умолчанию возвращают <b>undefined</b>, обернутый в промис.</p><p>По цепочке передаётся не сам промис, а его результат.</p><h3>catch</h3><p>Под капотом <b>catch</b> содержит вызов <b>then</b>, где первым аргументом передан <b>undefined</b>.</p><h3>finally</h3><p>Метод <b>finally</b> принимает один аргумент — колбэк, который будет выполнен после завершения промиса вне зависимости от его состояния.</p><pre><code>promise.finally(onFinally);</code></pre><ul><li>Обработчик <b>finally</b> не получает результат предыдущего обработчика (у него нет аргументов). Вместо этого этот результат передается следующему подходящему обработчику.</li><li>Обработчик <b>finally</b> не должен ничего возвращать. Если возвращает что-то, то это игнорируется.</li></ul><p>Обработка промисов всегда асинхронная, т.к. все действия промисов проходят через внутреннюю очередь «promise jobs», так называемую «очередь микрозадач (microtask queue)» (термин v8).</p><p>Таким образом, обработчики в <b>then</b>/<b>catch</b>/<b>finally</b> вызываются после выполнения текущего кода.</p><p>Если промис в состоянии ожидания, обработчики в <b>then</b>/<b>catch</b>/<b>finally</b> будут ждать его. Если обработчик добавляется к уже выполенному промису, то он запускается немедленно.</p><h2>Методы глобального объекта Promise</h2><h3>resolve и reject</h3><pre><code>Promise.resolve(value);
Promise.reject(reason);</code></pre><p>Метод <b>resolve</b> возвращает промис выполненный с переданным значением.</p><p>Метод <b>reject</b> возвращает промис, который был отклонён по указанной причине.</p><p>На практике эти методы применяются в первую очередь для целей разработки: проверки кода, написания вспомогательных функций на промисах и т. д.</p><h3>Методы для обработки нескольких промисов</h3><p>Следующие методы в качестве аргумента принимают промисы в виде перечисляемого объекта, например, массива.</p><pre><code>Promise.метод(iterable);</code></pre><p>Если какой-либо элемент перечисляемого объекта не является промисом, то он будет преобразован с помощью метода <b>Promise.resolve</b>.</p><h3>all</h3><p>Метод <b>all</b> возвращает промис, который выполнится когда будут выполнены все переданные промисы или отклонится, сразу как будет отклонен любой из них.</p><p>В случае выполнения результатом станет массив результатов переданных промисов, сохраняющий порядок оригинального перечисляемого объекта.</p><p>В случае отклонения результатом станет результат отклонённого промиса.</p><p>Если в качестве аргумента будет передан пустой массив, то возвращаемый промис будет выполнен немедленно с результатом в виде пустого массива.</p><h3>allSettled</h3><p>Метод <b>allSettled</b> возвращает промис, который выполнится когда все переданные промисы будут завершены.</p><p>Результатом станет массив объектов, каждый их которых содержит информацию об одном из завершенных промисов: статус в свойстве <b>status</b> и его результат в свойстве <b>value</b> или <b>reason</b> в зависимости от статуса.</p><p>Если в качестве аргумента будет передан пустой массив, то возвращаемый промис будет выполнен немедленно с результатом в виде пустого массива.</p><h3>any</h3><p>Метод <b>any</b> возвращает промис, который выполнится когда будет выполнен любой из переданных промисов или отклонится, если все переданные промисы будут отклонены.</p><p>В случае выполнения результатом станет результат промиса, выполнившегося первым.</p><p>В случае отклонения результатом станет ошибка <b>AggregateError: All promises were rejected</b>, которая в своём свойстве <b>errors</b> хранит все результаты отклоненных промисов.</p><p>Если в качестве аргумента будет передан пустой массив, то возвращаемый промис будет немедленно отклонён.</p><h3>race</h3><p>Метод <b>race</b> возвращает промис, который выполнится или отклонится в зависимости от статуса промиса, завершившегося первым.</p><p>Результатом станет результат промиса, завершившегося первым.</p><p>Если в качестве аргумента будет передан пустой массив, то возвращаемый промис останется в состоянии <b>"pending"</b>.</p><h2>unhandledrejection</h2><p>Если происходит ошибка, и отсутствует её обработчик, то генерируется событие <b>unhandledrejection</b>, и соответствующий объект <b>event</b> содержит информацию об ошибке.</p><pre><code>window.addEventListener('unhandledrejection', function(event) {
  // объект события имеет два специальных свойства:
  alert(event.promise); // [object Promise] - промис, который сгенерировал ошибку
  alert(event.reason); // Error: Ошибка! - объект ошибки, которая не была обработана
});</code></pre><p>Это даёт возможность отслеживать необработанные ошибки и информировать о них пользователя (и, возможно, наш сервер), благодаря чему наше приложение никогда не будет «просто умирать».</p></article></main><footer class="page-footer"><div class="container">=^-^=</div></footer></div></body></html>