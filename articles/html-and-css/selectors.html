<!DOCTYPE html><html class="page" lang="ru"><head><meta charset="utf-8"><title>Селекторы.</title><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="stylesheet" href="../../css/style.min.css"></head><body class="page__body"><div class="page__inner"><header class="page-header"><div class="container"><a class="logo" href="../../index.html">Umnyasha Web</a></div></header><main><article class="article article--with-navigation container"><h1>Селекторы.</h1><nav><ol><li><a href="#selector-by-tag">Селектор по тегу.</a></li><li><a href="#selector-by-class">Селектор по классу.</a></li><li><a href="#context-selectors">Контекстные селекторы.</a></li><li><a href="#child-selectors">Дочерние селекторы.</a></li><li><a href="#adjacent-selectors">Соседние селекторы.</a></li><li><a href="#subsequent-element-selector">Селектор последующих элементов.</a></li><li><a href="#selector-by-id">Селектор по id.</a></li><li><a href="#selector-by-attribute">Селектор по атрибуту.</a><ol><li><a href="#selector-by-attribute-start-substring">Селектор по подстроке в начале значения атрибута.</a></li><li><a href="#selector-by-attribute-end-substring">Селектор по подстроке в конце значения атрибута.</a></li><li><a href="#selector-by-attribute-substring">Селектор по подстроке в значении атрибута.</a></li><li><a href="#selector-by-attribute-word"> Селектор по слову в значении атрибута.</a></li><li><a href="#selector-by-attribute-prefix">Селектор по префиксу в значении атрибута.</a></li></ol></li><li><a href="#pseudo-classes">Псевдоклассы.</a><ol><li><a href="#pseudo-class-root">Псевдокласс root.</a></li><li><a href="#pseudo-class-counter">Выбор элементов на основе счётчика.</a></li><li><a href="#pseudo-classes-interactive">Псевдоклассы для интерактивных элементов.</a></li><li><a href="#pseudo-classes-form">Псевдоклассы для полей формы.</a></li><li><a href="#pseudo-classes-helper">Вспомогательные псевдоклассы.</a></li></ol></li><li><a href="#pseudo-elements">Псевдоэлементы.</a><ol><li><a href="#pseudo-elements-text">Псевдоэлементы для оформления текста.</a></li><li><a href="#pseudo-elements-before-after">Псевдоэлементы before и after.</a></li></ol></li><li><a href="#combining-selectors">Комбинирование селекторов.</a><ol><li><a href="#selector-by-tag-and-class">Селектор по тегу и классу.</a></li><li><a href="#using-subsequent-with-checked">Использование ~ с checked.</a></li><li><a href="#association-of-pseudo-classes">Объединение псевдоклассов.</a></li><li><a href="#using-context-with-nth-child">Псевдокласс nth-child и контекстные селекторы.</a></li><li><a href="#styling-depending-on-quantity"> Динамическая стилизация элементов в зависимости от их количества.</a></li></ol></li></ol></nav><h2 id="selector-by-tag">Селектор по тегу.</h2><p>Селектор по тегу содержит название тега без символов <b>&lt;</b> и <b>&gt;</b>, и выбирает все теги с таким названием.</p><p>Пример:</p><pre><code>li {
  /* Стили для элементов списка. */
}</code></pre><h2 id="selector-by-class">Селектор по классу.</h2><P>Селектор по классу содержит название класса выбирает все элементы с таким классом.</P><p>Перед названием класса пишется точка (<b>.</b>).</p><p>Пример:</p><pre><code>.heading {
  /* Стили для класса heading. */
}</code></pre><h2 id="context-selectors">Контекстные селекторы.</h2><p>Можно комбинировать любые типы селекторов через пробел. Такие селекторы называются <i>вложенными</i> или <i>контекстными</i> и используются, чтобы применить стили к элементу, только если он вложен в нужный элемент. Читаются справа налево.</p><p>Пример:</p><pre><code>nav a { ... } /* Выберет теги a внутри тегов nav. */
.menu ul { ... } /* Выберет теги ul внутри тегов с классом menu. */
.post .title { ... } /* Выберет теги с классом title внутри тегов с классом post. */</code></pre><p>Комбинировать можно любое количество селекторов, но лучше использовать двойную или максимум тройную вложенность.</p><pre><code>/* Выберет все ссылки внутри элементов с классом menu, которые лежат внутри элементов с классом footer. */
.footer .menu a { ... }</code></pre><p>Вложенные селекторы спасают от необходимости придумывать имена классов и загромождать ими разметку. Можно задавать элементам различные стили в зависимости от их контекста. Например, если ссылка расположена внутри меню, сделать её крупнее, а если внутри основного текста, то задать ей нужный цвет.</p><h2 id="child-selectors">Дочерние селекторы.</h2><p><i>Потомками</i> называются любые элементы, расположенные внутри родительского элемента. А <i>дочерними</i> элементами называются ближайшие потомки.</p><p>Взгляните на пример:</p><pre><code>&lt;ul&gt;
  &lt;li&gt;&lt;span&gt; ... &lt;/span&gt;&lt;/li&gt;
  &lt;li&gt;&lt;span&gt; ... &lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;</code></pre><p>По отношению к списку <b>&lt;ul&gt;&lt;/ul&gt;</b> элементы <b>&lt;li&gt;&lt;/li&gt;</b> являются дочерними элементами и потомками, а <b>&lt;span&gt;&lt;/span&gt;</b> — потомки, но не дочерние элементы.</p><p>Контекстные селекторы влияют на всех потомков, что не всегда удобно. Иногда необходимо задать стили только для дочерних элементов. Для этого существует дочерний селектор, в котором используется символ <b>&gt;</b>.</p><p>Примеры:</p><pre><code>ul &gt; li { ... }
ul &gt; li &gt; span { ... }</code></pre><h2 id="adjacent-selectors">Соседние селекторы.</h2><p>Контекстные селекторы используются для вложенных друг в друга элементов, а соседние — для расположенных рядом.</p><p>Например, теги <b>&lt;li&gt;&lt;/li&gt;</b> являются соседними по отношению друг к другу и вложенными в тег <b>&lt;ul&gt;&lt;/ul&gt;</b>.</p><p>Соседние селекторы записываются с помощью знака <b>+</b>, например, <b>селектор-1 + селектор-2</b>. Стили применятся к элементу, подходящему под <b>селектор-2</b>, только если <em>сразу</em> перед ним расположен элемент, подходящий под <b>селектор-1</b>.</p><p>Пример. Есть два элемента списка:</p><pre><code>&lt;ul&gt;
  &lt;li class="hit"&gt; ... &lt;/li&gt;
  &lt;li class="miss"&gt; ... &lt;/li&gt;
&lt;/ul&gt;</code></pre><p>Селектор <b>.hit</b> + <b>.miss</b> применит стили к элементу с классом <b>miss</b>, так как перед ним есть элемент с классом <b>hit</b>.</p><p>Селектор <b>.hit + li</b>, а также селектор <b>li + .miss</b>, или даже <b>li + li</b> тоже применит стили к элементу с классом <b>miss</b>, то есть ко второму элементу списка.</p><p>А вот селектор <b>.miss + .hit</b> не сработает, так как в разметке перед элементом с классом <b>hit</b> нет элемента с классом <b>miss</b>.</p><h2 id="subsequent-element-selector">Селектор последующих элементов.</h2><p>Селекторы последующих элементов записываются с помощью знака <b>~</b>, например, <b>селектор-1 ~ селектор-2</b>. Стили применятся к элементу, подходящему под <b>селектор-2</b>, только если перед ним расположен элемент, подходящий под <b>селектор-1</b>. Оба элемента должны находиться на одном уровне вложенности.</p><p>Отличие от соседнего селектора <b>+</b> состоит в том, что между элементами <b>селектор-1</b> и <b>селектор-2</b> могут находиться другие элементы.</p><p>Пример:</p><pre><code>&lt;ul class="cards"&gt;
  &lt;li class="king diamond"&gt;&lt;/li&gt;
  &lt;li class="queen heart"&gt;&lt;/li&gt;
  &lt;li class="jack spade"&gt;&lt;/li&gt;
  &lt;li class="ace heart"&gt;&lt;/li&gt;
  &lt;li class="king club"&gt;&lt;/li&gt;
&lt;/ul&gt;</code></pre><p>Сравним два селектора:</p><pre><code>.queen.heart + li { ... }
.king.diamond ~ li { ... }</code></pre><p>В первом случае выберется одна карта, расположенная сразу за червовой дамой, то есть пиковый валет.</p><p>Во втором случае выделятся все карты, которые стоят за бубновым королём, то есть червовая дама, пиковый валет, червовый туз и трефовый король.</p><h2 id="selector-by-id">Селектор по id.</h2><P>Селектор по идентификатору (HTML-атрибуту <b>id</b>) содержит название идентификатора и выбирает элемент с таким идентификатором.</P><p>Перед названием идентификатора пишется символ <b>#</b>.</p><p>Пример:</p><pre><code>&lt;!-- HTML --&gt;
&lt;p id="greeting"&gt;Приветствие!&lt;/p&gt;

/* CSS */
#greeting {
  ...
}</code></pre><p>Использование селекторов по <b>id</b> при оформлении считается плохой практикой. Существуют редкие исключения из этого правила, например, при оживлении слайдера на чистом CSS.</p><h2 id="selector-by-attribute">Селектор по атрибуту.</h2><p>Существуют селекторы, которые позволяют выбирать элементы по атрибутам.</p><p>Чаще всего такие селекторы используются при работе с формами, так как поля форм имеют атрибут <b>type</b> с разными значениями.</p><p>Селекторы атрибутов записываются с использованием квадратных скобок: <b>&#91;атрибут&#93;</b>.</p><p>Примеры:</p><pre><code>input[checked] { ... }
input[type="text"] { ... }</code></pre><p>Первый селектор выберет поля формы, у которых есть атрибут <b>checked</b>, второй селектор выберет поля формы, у которых атрибут <b>type</b> имеет значение <b>text</b>.</p><p>Селектор по атрибуту не обязательно использовать в комбинации с селектором по тегу.</p><h3 id="selector-by-attribute-start-substring">Селектор по подстроке в начале значения атрибута.</h3><p>Селектор <b>&#91;имя_атрибута^="подстрока"&#93;</b> выбирает все элементы, у которых значение атрибута начинается с указанной подстроки.</p><p>Например, есть 3 блока с классами <b>column-1</b>, <b>column-2</b> и <b>column-3</b>. Они имеют почти одинаковое оформление, разной является только ширина.</p><pre><code>&lt;div class="column-1"&gt; ... &lt;/div&gt;
&lt;div class="column-2"&gt; ... &lt;/div&gt;
&lt;div class="column-3"&gt; ... &lt;/div&gt;</code></pre><p>Чтобы не дублировать CSS-код, можно вынести общие свойства в правило с селектором <b>&#91;class^="column-"&#93;</b>, а в остальных правилах задать только ширину.</p><pre><code>[class^="column-"] {
  /* Общие свойства: отступы, рамки, фон и т.п. */
}

.column-1 { width: 100px; }
.column-2 { width: 200px; }
.column-3 { width: 300px; }</code></pre><h3 id="selector-by-attribute-end-substring">Селектор по подстроке в конце значения атрибута.</h3><p>Селектор <b>&#91;имя_атрибута$="подстрока"&#93;</b> выбирает все элементы, у которых значение атрибута оканчивается указанной подстрокой.</p><p>Например, на сайте есть раздел с файлами для скачивания в разных форматах и нужно для каждого типа файлов добавить свою иконку.</p><pre><code>&lt;a href="book.pdf" download&gt;Скачать&lt;/a&gt;
&lt;a href="book.doc" download&gt;Скачать&lt;/a&gt;
&lt;a href="book.fb2" download&gt;Скачать&lt;/a&gt;</code></pre><p>В этом случае в CSS можно назначать иконки по расширениям файлов:</p><pre><code>a[href$=".pdf"] { /* Иконка для PDF. */ }
a[href$=".doc"] { /* Иконка для DOC. */ }
a[href$=".fb2"] { /* Иконка для FB2. */ }</code></pre><h3 id="selector-by-attribute-substring">Селектор по подстроке в значении атрибута.</h3><p>Селектор <b>&#91;имя_атрибута*="подстрока"&#93;</b> выбирает все элементы, значение атрибута которых содержит указанную подстроку на любой позиции.</p><p>Например, среди трёх элементов:</p><pre><code>&lt;p class="person-name"&gt; ... &lt;/p&gt;
&lt;div class="some-person-info"&gt; ... &lt;/div&gt;
&lt;span class="date-person"&gt; ... &lt;/span&gt;</code></pre><p>cелектор <b>&#91;class*="person"&#93;</b> выберет все.</p><h3 id="selector-by-attribute-word">Селектор по слову в значении атрибута.</h3><p>Селектор <b>&#91;имя_атрибута~="слово"&#93;</b> выбирает все элементы, у которых значение атрибута содержит указанное слово.</p><p>Входить должно именно слово, а не просто подстрока. То есть слово должно содержать с обеих сторон разделители: пробелы или начало/конец строки.</p><h3 id="selector-by-attribute-prefix">Селектор по префиксу в значении атрибута.</h3><p>Селектор <b>&#91;имя_атрибута|="префикс"&#93;</b> выбирает все элементы, у которых значение атрибута содержит указанный префикс, то есть либо полностью совпадает с префиксом, либо начинается c префикса, за которым сразу следует дефис (<b>-</b>).</p><pre><code>[имя_атрибута|="префикс"] { ... }
/*
Этот селектор заменяет собой два других:
[имя_атрибута="префикс"]
[имя_атрибута^="префикс-"]
*/</code></pre><h2 id="pseudo-classes">Псевдоклассы.</h2><p><dfn>Псевдоклассы</dfn> — это селекторы, которые могут использоваться самостоятельно или как дополнения к другим селекторам, делая их специфичнее.</p><p>Имена псевдоклассов начинаются с двоеточия (<b>:</b>), вот так <b>:псевдокласс</b>.</p><p>Примеры:</p><pre><code>a:visited { ... }
li:last-child { ... }
.alert:hover { ... }</code></pre><h3 id="pseudo-class-root">Псевдокласс root.</h3><ul><li><a href="../css-pseudo-classes/root.html">root</a> — корневой элемент дерева документа.</li></ul><h3 id="pseudo-class-counter">Выбор элементов на основе счётчика.</h3><ul><li><a href="../css-pseudo-classes/first-child.html">first-child</a> — первый  элемент родителя.</li><li><a href="../css-pseudo-classes/last-child.html">last-child</a> — последний элемент родителя.</li></ul><ul><li><a href="../css-pseudo-classes/first-of-type.html">first-of-type</a> — первые элементы разных типов среди дочерних.</li><li><a href="../css-pseudo-classes/last-of-type.html">last-of-type</a> — последние элементы разных типов среди дочерних.</li></ul><ul><li><a href="../css-pseudo-classes/nth-child.html">nth-child</a> — элемент по порядкому номеру с начала.</li><li><a href="../css-pseudo-classes/nth-last-child.html">nth-last-child</a> — элемент по порядкому номеру с конца.</li></ul><ul><li><a href="../css-pseudo-classes/nth-of-type.html">nth-of-type</a> — элементы разных типов по порядкому номеру с начала.</li><li><a href="../css-pseudo-classes/nth-last-of-type.html">nth-last-of-type</a> — элементы разных типов по порядкому номеру с конца.</li></ul><ul><li><a href="../css-pseudo-classes/only-child.html">only-child</a> — единственные элементы в родителе.</li><li><a href="../css-pseudo-classes/only-of-type.html">only-of-type</a> — единственные элементы своего типа в родителе.</li></ul><ul><li><a href="../css-pseudo-classes/empty.html">empty</a> — пустые элементы.</li></ul><h3 id="pseudo-classes-interactive">Псевдоклассы для интерактивных элементов.</h3><ul><li><a href="../css-pseudo-classes/link.html">link</a> — непосещённые ссылки.</li><li><a href="../css-pseudo-classes/visited.html">visited</a> — посещённые ссылки.</li><li><a href="../css-pseudo-classes/focus.html">focus</a> — элементы в фокусе.</li><li><a href="../css-pseudo-classes/hover.html">hover</a> — элементы при наведении.</li><li><a href="../css-pseudo-classes/active.html">active</a> — элементы при нажатии.</li></ul><ul><li><a href="../css-pseudo-classes/focus-visible.html">focus-visible</a> — элементы в фокусе с клавиатуры.</li><li><a href="../css-pseudo-classes/focus-within.html">focus-within</a> — элементы в фокусе, либо имеющие потомков в фокусе.</li></ul><p>Пример стилизации ссылок:</p><pre><code>a:link { ... }
a:visited { ... }
a:focus { ... }
a:hover { ... }
a:active { ... }</code></pre><p>Обратите внимание на порядок правил. Если их расположить по-другому, то некоторые могут не сработать.</p><h3 id="pseudo-classes-form">Псевдоклассы для полей формы.</h3><ul><li><a href="../css-pseudo-classes/enabled.html">enabled</a> — доступные поля (без атрибута <b>disabled</b>).</li><li><a href="../css-pseudo-classes/disabled.html">disabled</a> — заблокированные поля (с атрибутом <b>disabled</b>).</li></ul><ul><li><a href="../css-pseudo-classes/read-only.html">read-only</a> — поля, доступные только для чтения (с атрибутом <b>read-only</b>).</li><li><a href="../css-pseudo-classes/read-write.html">read-write</a> — поля без атрибута <b>read-only</b>.</li></ul><ul><li><a href="../css-pseudo-classes/required.html">required</a> — обязательные для заполнения поля (с атрибутом <b>required</b>).</li><li><a href="../css-pseudo-classes/optional.html">optional</a> — поля без атрибута <b>required</b>.</li></ul><ul><li><a href="../css-pseudo-classes/checked.html">checked</a> — отмеченные поля.</li></ul><ul><li><a href="../css-pseudo-classes/valid.html">valid</a> — валидно заполненные поля.</li><li><a href="../css-pseudo-classes/invalid.html">invalid</a> — поля, заполненные невалидно.</li></ul><ul><li><a href="../css-pseudo-classes/in-range.html">in-range</a> — числовые поля со значениями в заданном диапазоне.</li><li><a href="../css-pseudo-classes/out-of-range.html">out-of-range</a> — числовые поля со значениями вне заданного диапазона.</li></ul><h3 id="pseudo-classes-helper">Вспомогательные псевдоклассы.</h3><ul><li><a href="../css-pseudo-classes/not.html">not</a> — отрицание наличия другого селектора.</li></ul><h2 id="pseudo-elements">Псевдоэлементы</h2><p>Псевдоэлементы добавляются к селектору с помощью символа <b>::</b>, вот так <b>селектор::псевдоэлемент</b>.</p><h3 id="pseudo-elements-text">Псевдоэлементы для оформления текста.</h3><ul><li><a href="../css-pseudo-elements/first-letter.html">first-letter</a> — первый символ текста.</li><li><a href="../css-pseudo-elements/first-line.html">first-line</a> — первая строка текста.</li></ul><h3 id="pseudo-elements-before-after">Псевдоэлементы before и after.</h3><ul><li><a href="../css-pseudo-elements/before.html">before</a> — псевдо-span в начале элемента.</li><li><a href="../css-pseudo-elements/after.html">after</a> — псевдо-span в конце элемента.</li></ul><p>Псевдоэлементам <b>before</b> и <b>after</b> можно задавать любые CSS-свойства: менять их тип бокса, задавать позиционирование, отступы, фон и так далее.</p><p>Этими возможностями особенно часто пользуются при создании различных декоративных эффектов. Это очень удобно. Во-первых, не нужно добавлять лишний тег под каждую очередную мелкую иконку. Во-вторых, можно управлять этими иконками/декоративными элементами только с помощью CSS, что открывает огромный простор для создания интересных динамических эффектов.</p><h2 id="combining-selectors">Комбинирование селекторов.</h2><p>В CSS можно очень гибко комбинировать селекторы в неограниченном количестве.</p><p>Например, селектор <b>.player-1 .hit + .miss</b> сработает для тега с классом <b>miss</b>, если сразу перед ним расположен тег с классом <b>hit</b> и оба тега расположены внутри тега с классом <b>player-1</b>.</p><h3 id="selector-by-tag-and-class">Селектор по тегу и классу.</h3><p>Синтаксис CSS позволяет выбирать элементы одновременно по тегу и классу или же элемент с несколькими классами сразу. Для этого селектор составляется одной строкой из всех желаемых «частей» без пробелов.</p><p>В селекторе по тегу и классу первым пишется название тега, а потом класс:</p><pre><code>div.blue { ... }  /* Выберет теги div с классом blue. */
ul.target { ... } /* Выберет теги ul с классом target. */</code></pre><p>Если у элемента задано несколько классов, в HTML и в CSS-селекторе они могут быть записаны в любом порядке — это не будет влиять на выборку элементов.</p><pre><code>.text.green { ... } /* Выберет теги с классами text и green. */</code></pre><p>Количество классов в селекторе может быть любым:</p><pre><code>/* Выбор тегов span с 4 классами: underlined, red, big и text. */
span.underlined.red.big.text { ... }</code></pre><h3 id="using-subsequent-with-checked">Использование ~ с checked.</h3><p>Благодаря псевдоклассу <b>checked</b>, с помощью чистого CSS можно создавать очень много интересных эффектов, так как мы можем не просто выбирать отмеченные поля форм, но и влиять с помощью этих полей на другие элементы.</p><p>Для этого нужно комбинировать <b>checked</b> и <b>~</b>, который позволяет выбрать все элементы, идущие за отмеченным чекбоксом.</p><p>Пример:</p><pre><code>input:checked ~ .item {
  color: red;
}</code></pre><p>Такое CSS-правило задаст красный цвет всем элементам с классом <b>item</b>, расположенным после отмеченного поля.</p><p>Получается, что мы можем с помощью чекбоксов или радиокнопок управлять внешним видом других элементов. С помощью этого приёма, например, делают переключающиеся вкладки, которые работают без JavaScript.</p><h3 id="association-of-pseudo-classes">Объединение псевдоклассов.</h3><p>Псевдоклассы, как и любые другие селекторы, можно комбинировать между собой, соединять с селекторами другого типа и так далее.</p><p>Пример:</p><pre><code>input[type="checkbox"]:required:checked { ... }</code></pre><p>Селектор выберет все отмеченные чекбоксы, которые являются обязательными.</p><h3 id="using-context-with-nth-child">Псевдокласс nth-child и контекстные селекторы.</h3><p>Селекторы с псевдоклассами хорошо сочетаются с контекстными селекторами.</p><p>Например, следующий селектор выберет третий тег <b>&lt;li&gt;&lt;/li&gt;</b> внутри блока с классом <b>shooter-2</b>.</p><pre><code>.shooter-2 li:nth-child(3) { ... }</code></pre><p>Селектор не обязательно должен заканчиваться псевдоклассом. Например, следующий селектор выберет элемент с классом <b>text</b> в четвёртом элементе списка <b>&lt;li&gt;&lt;/li&gt;</b>.</p><pre><code>li:nth-child(4) .text { ... }</code></pre><h3 id="styling-depending-on-quantity">Динамическая стилизация элементов в зависимости от их количества.</h3><p>Задача:</p><p>Есть список из меняющегося числа элементов. Если элементов меньше 4, то они должны быть красными, если меньше 6, то жёлтыми, в противном случае зелёными.</p><pre><code>li {
  color: green;
}
li:nth-last-child(-n+5):first-child,
li:nth-last-child(-n+5):first-child ~ li {
  color: yellow;
}
li:nth-last-child(-n+3):first-child,
li:nth-last-child(-n+3):first-child ~ li {
  color: red;
}</code></pre><p>Сначала зададим цвет по умолчанию — зелёный.</p><p>Второе правило выбирает последние 5 элементов и если среди них есть первый элемент списка, значит элементов в списке 5 или меньше, селекторы сработают и закрасит элементы в жёлтый.</p><p>Третье правило выбирает последние 3 элемента и если среди них есть первый элемент списка, значит элементов в списке 3 или меньше, селекторы сработают и переопределит жёлтый цвет в красный. Важно, чтобы это правило располагалось ниже второго.</p></article></main><footer class="page-footer"><div class="container">=^-^=</div></footer></div></body></html>