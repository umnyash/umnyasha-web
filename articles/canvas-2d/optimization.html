<!DOCTYPE html><html class="page" lang="ru"><head><meta charset="utf-8"><title>Советы по оптимизации.</title><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="stylesheet" href="../../css/style.min.css"></head><body class="page__body"><div class="page__inner"><header class="page-header"><div class="container"><a class="logo" href="../../index.html">Umnyasha Web</a></div></header><main><article class="article container"><h1>Советы по оптимизации.</h1><h2>Предварительная визуализация похожих примитивов или повторяющихся объектов на закадровом холсте.</h2><p>Если в каждом кадре анимации повторяются одни и те же операции, их можно выгрузить на закадровый холст. Затем отрисовывать это закадровое изображение на основной холст, без необходимости повторять шаги для его создания.</p><p>Пример:</p><pre><code>myCanvas.offscreenCanvas = document.createElement('canvas');
myCanvas.offscreenCanvas.width = myCanvas.width;
myCanvas.offscreenCanvas.height = myCanvas.height;

myCanvas.getContext('2d').drawImage(myCanvas.offScreenCanvas, 0, 0);</code></pre><h2>Использование целочисленных координат, вместо координат с плавающей запятой.</h2><p>Отрисовка объектов с дробными значениями координат заставляет браузер выполнять дополнительные вычисления для создания эффекта сглаживания. Чтобы избежать этого, можно, например, округлить все координаты с помощью <b>Math.floor</b>.</p><h2>Не масштабируйте изображения в drawImage.</h2><p>Кэшируйте изображения различных размеров на закадровом холсте при загрузке, а не постоянно масштабируйте их в <b>drawImage</b>.</p><h2>Использование нескольких слоёв холста для сложных сцен.</h2><p>В вашем приложении вы можете обнаружить, что некоторые объекты необходимо часто перемещать или изменять, в то время как другие остаются относительно статичными. Возможная оптимизация в этой ситуации — наслоить ваши элементы, используя несколько элементов <b>&lt;canvas&gt;&lt;/canvas&gt;</b>.</p><p>Например, предположим, что у вас есть игра с пользовательским интерфейсом вверху, игровым процессом посередине и статическим фоном внизу. В этом случае вы можете разделить игру на три слоя Canvas. Пользовательский интерфейс будет меняться только при вводе данных пользователем, слой игрового процесса будет меняться с каждым новым кадром, а фон в целом останется неизменным.</p><h2>Используйте простой CSS для больших фоновых изображений.</h2><p>Если у вас есть статическое фоновое изображение, вы можете нарисовать его на простом элементе <b>&lt;div&gt;&lt;/div&gt;</b>, используя CSS-свойство <b>background</b>, и поместить его под холст. Это избавит от необходимости отрисовывать фон на холсте при каждом кадре.</p><h2>Масштабирование холста с помощью CSS-трансформаций.</h2><P>Преобразования CSS выполняются быстрее, поскольку они используют графический процессор. Лучше всего не масштабировать холст или иметь холст меньшего размера и увеличивать его, нежели иметь большой холст и уменьшать его.</P><p>Пример:</p><pre><code>const scaleX = window.innerWidth / canvas.width;
const scaleY = window.innerHeight / canvas.height;

const scaleToFit = Math.min(scaleX, scaleY);
const scaleToCover = Math.max(scaleX, scaleY);

stage.style.transformOrigin = '0 0'; //scale from top left
stage.style.transform = `scale(${scaleToFit})`;</code></pre><h2>Отключение прозрачности.</h2><p>Если ваше приложение использует холст и не нуждается в прозрачном фоне, установите для параметра альфа значение <b>false</b> при создании контекста рисования с помощью <b>HTMLCanvasElement.getContext</b>. Эта информация может использоваться браузером внутри для оптимизации рендеринга.</p><pre><code>const ctx = canvas.getContext('2d', { alpha: false });</code></pre><h2>Масштабирование для дисплеев с высоким разрешением.</h2><p>Вы можете обнаружить, что элементы холста выглядят размытыми на дисплеях с более высоким разрешением. Хотя может существовать множество решений, простым первым шагом является одновременное масштабирование размера холста вверх и вниз, используя его атрибуты, стиль и масштаб контекста.</p><pre><code>// Get the DPR and size of the canvas
const dpr = window.devicePixelRatio;
const rect = canvas.getBoundingClientRect();

// Set the "actual" size of the canvas
canvas.width = rect.width * dpr;
canvas.height = rect.height * dpr;

// Scale the context to ensure correct drawing operations
ctx.scale(dpr, dpr);

// Set the "drawn" size of the canvas
canvas.style.width = `${rect.width}px`;
canvas.style.height = `${rect.height}px`;</code></pre><h2>Ещё советы:</h2><ul><li>Пакетный вызов Canvas. Например, нарисуйте полилинию вместо нескольких отдельных линий.</li><li>Избегайте ненужных изменений состояния холста.</li><li>Отрисовывайте только различия экрана, а не все новое состояние.</li><li>По возможности избегайте свойства <a href="shadow-blur.html">shadowBlur</a>.</li><li>По возможности избегайте рендеринга текста.</li><li>Попробуйте разные способы очистки холста (<b>clearRect</b>, <b>fillRect</b> и изменение размера холста).</li><li>Для анимации используйте <b>window.requestAnimationFrame</b> вместо <b>setInterval</b>.</li><li>Будьте осторожны с тяжелыми физическими библиотеками.</li></ul></article></main><footer class="page-footer"><div class="container">=^-^=</div></footer></div></body></html>